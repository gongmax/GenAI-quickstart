# Copyright 2024 Google LLC All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http:#www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from flask import Flask, render_template, request
from flask_socketio import SocketIO, emit
from swagger_client.rest import ApiException
import time
import logging  # Import the logging module
import random
import requests
import base64
import os
import swagger_client as Agones
import threading

# Uncomment to use Stable Diffusion explicitly - requires the Stable Diffusion backend, which uses a GPU:
#   kubectl scale deployment/stable-diffusion-endpt --replicas=1 -ngenai
# IMAGE_GENERATION_ENDPOINT="http://stable-diffusion-api.genai.svc"

# Use whatever the GenAI API is routing to (default Vertex)
IMAGE_GENERATION_ENDPOINT="http://genai-api.genai.svc/genai/image"

app = Flask(__name__,
            static_folder="static")
app.config['SECRET_KEY'] = f'{int(random.random()*100000000)}'
socketio = SocketIO(app)

# create an instance of the API class
PORT=os.environ.get("AGONES_SDK_HTTP_PORT","9358")
conf = Agones.Configuration()
conf.host = "http://localhost:"+PORT

# The nested dictionary to store the prompts and pictures for each round of each player
# The outer dictionary is indexed by the player id, and the inner dictionary is indexed by the round number
player_prompt = {}
# The nested dictionary to store the guesses and pictures for each round of each player
# The outer dictionary is indexed by the player id, and the inner dictionary is indexed by the round number
player_guess = {}
# The set to store the players who have clicked the "New Game" button
dropped_players = set()

logging.basicConfig(level=logging.INFO)  # Set to logging.DEBUG for more verbose logs 
logger = logging.getLogger(__name__)  # Get a logger for your application

headers = {"Content-Type": "application/json"}

logger.debug('gameserver started')
logger.debug('Agones SDK port: %s', PORT)

body = Agones.SdkEmpty() # SdkEmpty
agones = Agones.SDKApi(Agones.ApiClient(conf))
agones.health(body)

# Retry connection to Agones SDK for 5 times if it fails
retry = 5
while retry != 0:
    try:
        retry = retry - 1
        agones.ready(body)
        break
    except:
        time.sleep(2)
        logger.debug('retry connection')

def agones_health():
    while True:
        try:
            api_response = agones.health(body)
            logger.debug('health check reponse: %s', api_response)
            time.sleep(2)
        except ApiException as exc:
            logger.error('health check failed: %s', exc)

health_thread = threading.Thread(target=agones_health)
health_thread.start()

@app.route('/')
def index():
    global frontend_url
    frontend_url = request.args.get('originalIP')
    return render_template('index.html')

game_round = 3
embedding_endpoint = 'http://embeddings-api'

# When player click "New Game" button
@socketio.on('playAgain')
def handle_message(data):
    player_id = request.sid
    logger.debug('Received playAgain from player %s', player_id)
    dropped_players.add(player_id)
    emit('frontend_url', {'frontendURL': frontend_url}, room=player_id)
    # If both players have clicked the "New Game" button, shutdown the gameserver
    if len(dropped_players) == 2:
        agones.shutdown(body)

# When player submit the guess
@socketio.on('guess')
def handle_message(data):
    player_id = request.sid
    message = data['message']
    oppontent_id = data['opponentId']
    round = int(data['round'])

    logger.debug('Received guess %s from player %s for oppontent %s: %s', str(round), player_id, oppontent_id, message)

    # Store the guess
    if player_guess.get(player_id) is None:
        player_guess[player_id] = {}
    player_guess[player_id][round] = {
        'guess': message
    }
    
    # Send next picture which is generated by the opponent's prompt
    if round != game_round:
        next_round = round + 1
        while player_prompt[oppontent_id][next_round]['picture'] is None:
            time.sleep(0.1)
        emit('guess_sketch_response', {'image': player_prompt[oppontent_id][next_round]['picture'], 'prompt': player_prompt[oppontent_id][next_round]['prompt'], 'opponentId': oppontent_id, 'round': next_round}, room=player_id)
        logger.debug('Sent image %s to %s', str(next_round), player_id)

    # Generate and store the picture for the guess
    guess_payload = {
        'prompt': f'''{message}''',
    }
    model_response = requests.post(IMAGE_GENERATION_ENDPOINT, headers=headers, json=guess_payload)
    encoded_image = base64.b64encode(model_response.content).decode('utf-8')
    player_guess[player_id][round]['guess_picture'] = encoded_image
    # Send the guess picture to both the players, they will be shown in summary page
    emit('guess_response', {'image': encoded_image, 'guess': message, 'round': round, 'from': 'myself'}, room=player_id)
    emit('guess_response', {'image': encoded_image, 'guess': message, 'round': round, 'from': 'other'}, room=oppontent_id)

    # Generate and send the similarity score
    similarity_prompt = f'''calculate the vector similarity number between '{player_prompt[oppontent_id][round]['prompt']}' and '{player_guess[player_id][round]['guess']}' as number A,
                            Return number A in the format: A = '''
    similarity_payload = {
        'prompt': f'''{similarity_prompt}''',
    }
    similarity_response = requests.post(f'http://genai-api.genai.svc/genai/text', headers=headers, json=similarity_payload)
    similarity_response_without_quota = similarity_response.text.strip('"')
    score = float(similarity_response_without_quota.split()[-1])
    player_prompt[player_id][round]['guess_score'] = score
    # Send the score to both the players, they will be shown in summary page
    emit('score_response', {'score': score, 'round': round, 'from': 'myself'}, room=player_id)
    emit('score_response', {'score': score, 'round': round, 'from': 'other'}, room=oppontent_id)

# When player submit the prompt for generating Sketch
@socketio.on('prompt')
def handle_message(data):
    player_id = request.sid
    message = data['message']
    round = int(data['round'])
    logger.debug('Received prompt %s from player %s: %s', str(round), player_id, message)

    # Store the prompt
    if player_prompt.get(player_id) is None:
        player_prompt[player_id] = {}
    player_prompt[player_id][round] = {
        'prompt': message
    }

    # Generate and store the picture for the prompt\
    picture_generate_payload = {
        'prompt': f'''{message}''',
    }
    model_response = requests.post(IMAGE_GENERATION_ENDPOINT, headers=headers, json=picture_generate_payload)
    encoded_image = base64.b64encode(model_response.content).decode('utf-8')
    player_prompt[player_id][round]['picture'] = encoded_image

    # Send the generated picture back to the player, this will be shown in the summary page
    emit('prompt_response', {'image': encoded_image, 'prompt': message, 'round': round}, room=player_id)
    
    # Now check whether it's time to send the picture to the opponent for guessing
    # The first picture should be displayed if both players have entered all their prompts
    # The first picture page should be displayed only if the picture is generated
    if round != game_round:
        return
    while len(player_prompt) != 2:
        time.sleep(0.1)
    for player in player_prompt:
        if player != player_id:
            while len(player_prompt[player]) != game_round:
                time.sleep(0.1)
            while 'picture' not in player_prompt[player][1]:
                time.sleep(0.1)
            # Send the first picture to the opponent for guessing
            emit('guess_sketch_response', {'image': player_prompt[player][1]['picture'], 'prompt': player_prompt[player][1]['prompt'], 'opponentId': player, 'round': 1}, room=player_id)

if __name__ == '__main__':
    socketio.run(app, debug=True, host='0.0.0.0', port=7654)
